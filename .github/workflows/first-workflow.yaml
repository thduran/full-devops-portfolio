# defines name of the worflow
name: simple-workflow

# defines the trigger
on:
  push:
    branches: ["main"]

  workflow_dispatch: # allows to run workflow manually

jobs:
  # # defines the job name
  # hello-world-job:
  #   # defines the runner. It's needed after every job name
  #   runs-on: ubuntu-latest

  #   # defines the job steps
  #   steps:
  #     - name: Display Hello World
  #       run: echo "Hello World!"

  #     - name: Second action
  #       run: | # allows several commands in a single action
  #         echo "You created a worflow"
  #         echo "Congrats!"

  #     - name: Script Python
  #       run: |
  #         var = "Hi there"
  #         print(var)
  #       shell: python # allow to run python scripts
  
  # node-installation-job:
  #  runs-on: ubuntu-latest
  #  needs: [hello-world-job] # defines job dependency
  #  steps:
  #    - name: Node JS version check
  #      run: node --version
  #    - name: Newest version installation
  #      uses: actions/setup-node@v6 # instead of running commands, we can call an action
  #      with:
  #        node-version: '22.21.0' # declaring node version we want. See action documentation
  #    - name: Node JS version check after update
  #      run: node --version

  CI:
    runs-on: ubuntu-latest
    steps:
    
    - name: Obtaining code
      uses: actions/checkout@v5 # when the workflow file is in the same directory of the code, the definition of code path isn't needed
    
    - name: Setup Go environment
      uses: actions/setup-go@v5 # ensures correct go version
      with:
        go-version: '1.22.x'
    
    - name: Install Go dependencies
      working-directory: ./03-git/day-03
      run: go mod download # downloads all dependencies listed in ./03-git/day-02/go.mod

    - name: Run tests
      working-directory: ./03-git/day-03
      run: go test ./... -v # ./03-git/day-02/main_test.go

    - name: Logging in to Docker
      uses: docker/login-action@v3.1.0
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v6
      with:
        context: ./03-git/day-03 # the directory you're working with
        file: ./03-git/day-03/Dockerfile # Dockerfile path
        push: true # to automatically push image to Hub. Default is false
        tags: |
          thiagoduran/github-actions-test:v${{ github.run_number }}
          thiagoduran/github-actions-test:latest
        # run_number ensures version number incrementation
        # ensures push of tag latest (best practice)
        
  CD:
    runs-on: ubuntu-latest
    needs: [CI] # ensures that CD job will be run after CI job
    steps:

    - name: Obtaining code
      uses: actions/checkout@v5
    
    # - name: Configuring k8s context # action to set kubeconfig
    #   uses: azure/k8s-set-context@v4
    #   with:
    #     method: kubeconfig
    #     kubeconfig: ${{ secrets.k8s_config }} # the content of ~/.kube/config was set as a secret

    # --- MUDANÇA 1: Autenticar na AWS ---
    # Substituímos o 'azure/k8s-set-context' por credenciais reais da AWS.
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1 # IMPORTANTE: A mesma região do seu cluster EKS

    # --- MUDANÇA 2: Configurar o Kubectl ---
    # Em vez de usar um secret, usamos a AWS CLI para configurar o kubectl
    # O nome 'meu-cluster-minimo' deve ser o mesmo do seu Terraform.
    - name: Set up Kubectl for EKS
      run: |
        aws eks update-kubeconfig --name meu-cluster-minimo --region us-east-1
        
    - name: Manifest execution
      uses: azure/k8s-deploy@v5 # action to deploy app with k8s
      with:
        manifests: |
          ./03-git/day-03/k8s/deployment.yaml
        images: |
          thiagoduran/github-actions-test:v${{ github.run_number }}  
        # must match image set in k8s yaml